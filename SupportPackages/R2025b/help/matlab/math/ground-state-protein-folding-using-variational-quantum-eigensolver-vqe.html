<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://www.mathworks.com/help/schema/MathWorksDocPage">
<head>
<meta xmlns="http://www.w3.org/1999/xhtml" charset="utf-8">
<meta xmlns="http://www.w3.org/1999/xhtml" name="viewport" content="width=device-width, initial-scale=1.0">
<meta xmlns="http://www.w3.org/1999/xhtml" http-equiv="X-UA-Compatible" content="IE=edge">
<title>Ground-State Protein Folding Using Variational Quantum Eigensolver (VQE)</title>
<script xmlns="http://www.w3.org/1999/xhtml" type="application/ld+json">
      {
      "@context": "http://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement":
      [{
          "@type": "ListItem",
          "position": 1,

          "item": {
          "@id": "../index.html",
          "name": "MATLAB"
}

          } 
        ,
        {
          "@type": "ListItem",
          "position": 2,

          "item": {
          "@id": "../mathematics.html",
          "name": "Mathematics"
}

          }
        ,
        {
          "@type": "ListItem",
          "position": 3,

          "item": {
          "@id": "../quantum-computing.html",
          "name": "Quantum Computing"
}

          }
        ,
        {
          "@type": "ListItem",
          "position": 4,

          "item": {
          "@id": "../gate-based-quantum-computing.html",
          "name": "Gate-Based Quantum Computing"
}

          }]
      }</script><script xmlns="http://www.w3.org/1999/xhtml" type="application/ld+json">
        {
        "@context": "http://schema.org",
        "@type": "ItemList",
          "name": "VisibleBreadcrumbs",

        "itemListElement":
        [
        "gate-based-quantum-computing"
        ],
        "itemListOrder": "http://schema.org/ItemListOrderAscending"
        }
        </script><script xmlns="http://www.w3.org/1999/xhtml" type="application/ld+json">
        {
        "@context": "http://schema.org",
        "@type": "DigitalDocument",
          "headline": "Ground-State Protein Folding Using Variational Quantum Eigensolver (VQE)",
          "description": "An efficient method for using qubits to encode a protein fold on a 3-D tetrahedral lattice [1], [2]. The ground-state is found through a simulated variational quantum eigensolver (VQE) routine. The VQE algorithm uses classical optimization to improve the initial guess of the ground state, and then a quantum computer calculates the expectation value. The final circuit from the simulation is run on a real QPU for comparison.",
          "thumbnailURL": "../../examples/quantum/win64/ProteinFoldingVQEExample_06.png",
          "genre": "Live Script",
          "isBasedOn": {
          "@type": "Product",
          "name": "MATLAB"

        },
          "identifier": "quantum.ProteinFoldingVQEExample",
          "name": "ProteinFoldingVQEExample",
          "url": "ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html"

        }</script><script xmlns="http://www.w3.org/1999/xhtml" type="application/ld+json">
        {
        "@context": "http://schema.org",
        "@type": "PropertyValue",
          "name": "open_command",
          "value": "matlab:openExample('quantum/ProteinFoldingVQEExample')"

        }</script><script xmlns="http://www.w3.org/1999/xhtml" type="application/ld+json">
        {
        "@context": "http://schema.org",
        "@type": "ItemList",
          "name": "ExampleSourceFiles",

        "itemListElement":
        [
        "ProteinFoldingVQEExample.mlx"
        ],
        "itemListOrder": "http://schema.org/ItemListOrderAscending"
        }
        </script><link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/product/css/bootstrap.min.css" rel="stylesheet" type="text/css">


  <meta xmlns="http://www.w3.org/1999/xhtml" http-equiv="Content-Script-Type" content="text/javascript">
<meta xmlns="http://www.w3.org/1999/xhtml" name="toctype" itemprop="pagetype" content="ug">
<meta xmlns="http://www.w3.org/1999/xhtml" name="infotype" itemprop="infotype" content="other">

<meta xmlns="http://www.w3.org/1999/xhtml" name="description" itemprop="description" content="This example shows an efficient method for using qubits to encode a protein fold on a 3-D tetrahedral lattice [1], [2]."><meta xmlns="http://www.w3.org/1999/xhtml" content="../../examples/quantum/win64/ProteinFoldingVQEExample_06.png" itemprop="thumbnailUrl">
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/product/scripts/jquery/jquery-3.6.0.min.js"></script><script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/product/scripts/jquery/jquery-migrate.min.js"></script>
<link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/product/css/site6.css" rel="stylesheet" type="text/css">
<link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/product/css/site6_lg.css" rel="stylesheet" media="screen and (min-width: 1200px)">
<link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/product/css/site6_md.css" rel="stylesheet" media="screen and (min-width: 992px) and (max-width: 1199px)">
<link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/product/css/site6_sm+xs.css" rel="stylesheet" media="screen and (max-width: 991px)">
<link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/product/css/site6_sm.css" rel="stylesheet" media="screen and (min-width: 768px) and (max-width: 991px)">
<link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/product/css/site6_xs.css" rel="stylesheet" media="screen and (max-width: 767px)">
<link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/product/css/site6_offcanvas_v2.css" rel="stylesheet" type="text/css">
<link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/shared/highlight/styles/mwdochighlight.min.css" rel="stylesheet" type="text/css">

<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/scripts/l10n.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/scripts/docscripts.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/scripts/f1help.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/product/scripts/docscripts.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/scripts/mw.imageanimation.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/scripts/jquery.highlight.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/product/scripts/underscore-min.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/product/scripts/use_platform_screenshots.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/product/scripts/suggest.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/product/scripts/overload.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/scripts/helpservices.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/product/scripts/productfilter.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/scripts/matlab_dialog_shared.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/highlight/highlight.min.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/scripts/localstorage.js"></script><script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/scripts/product_group.js"></script><script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/scripts/saxonjs/SaxonJS2.rt.js"></script><script xmlns="http://www.w3.org/1999/xhtml">
            window.history.replaceState(window.location.href, null, ""); // Initialize
            window.onload = function() {    
            mystylesheetLocation = "../../includes/shared/scripts/product_group-sef.json";
            mysourceLocation = "../../docset/docset.xml";
            product_help_location = "matlab";
            pagetype = "section";
            doccentertype = "product";
            langcode = "";
            getProductFilteredList(mystylesheetLocation, mysourceLocation, product_help_location, pagetype, doccentertype, langcode);  
            }
          </script>




<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/product/scripts/jquery/jquery.mobile.custom.min.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/product/scripts/bootstrap.bundle.min.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/product/scripts/global.js"></script>
<link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/product/css/doc_center_base.css" rel="stylesheet" type="text/css">
<link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/product/css/doc_center_installed.css" rel="stylesheet" type="text/css">
<link xmlns="http://www.w3.org/1999/xhtml" href="../../includes/product/css/doc_center_print.css" rel="stylesheet" type="text/css" media="print">
<script xmlns="http://www.w3.org/1999/xhtml" src="../../includes/shared/equationrenderer/release/MathRenderer.js"></script>
</head>
<body id="responsive_offcanvas">
<div xmlns="http://www.w3.org/1999/xhtml" id="doc_header_spacer" class="header"></div>
<div xmlns="http://www.w3.org/1999/xhtml" class="section_header level_3"><div class="container-fluid"><div class="row" id="mobile_search_row"><div class="col-sm-6 col-md-7 has_horizontal_local_nav" id="section_header_title"><div class="section_header_content"><div class="section_header_title"><h1><a href="../../documentation-center.html">Help Center</a></h1></div></div></div><div class="col-12 col-sm-6 col-md-5" id="mobile_search"><div class="search_nested_content_container"><form id="docsearch_form" name="docsearch_form" method="get" data-release="R2025b" data-language="en" action="../../templates/searchresults.html"><div class="input-group tokenized_search_field"><label class="visually-hidden form-label">Search Help</label><input type="text" class="form-control conjoined_search" autocomplete="off" name="qdoc" placeholder="Search Help" id="docsearch"> <div><button type="submit" name="submitsearch" id="submitsearch" class="btn icon-search btn_search_adjacent btn_search icon_16" tabindex="-1"></button></div></div></form></div><button class="btn icon-remove btn_search float-end icon_32 d-sm-none" data-bs-toggle="collapse" href="#mobile_search" aria-expanded="false" aria-controls="mobile_search"></button></div><div class="d-sm-none" id="search_actuator"><button class="btn icon-search btn_search float-end icon_16" data-bs-toggle="collapse" href="#mobile_search" aria-expanded="false" aria-controls="mobile_search"></button></div></div></div></div><div class="row-offcanvas row-offcanvas-left">
<div xmlns="http://www.w3.org/1999/xhtml" class="sidebar-offcanvas" id="sidebar">
<nav class="offcanvas_nav" role="navigation">
<div class="offcanvas_actuator" data-bs-toggle="offcanvas" data-bs-target="#sidebar" id="nav_toggle"><button type="button" class="btn"><span class="visually-hidden">Off-Canvas Navigation Menu Toggle
                  Off-Canvas Navigation Menu Toggle</span><span class="icon-menu"></span></button><span class="offcanvas_actuator_label" id="translation_icon-menu" tabindex="-1" aria-hidden="true"></span></div><div class="nav_list_wrapper" id="nav_list_wrapper"><nav class="offcanvas_nav" role="navigation"><ul class="nav_breadcrumb" id="ul_left_nav_ancestors"><li itemscope="" itemtype="http://www.data-vocabulary.org/Breadcrumb" itemprop="breadcrumb"><a href="../../documentation-center.html?s_tid=CRUX_lftnav" itemprop="url"><span itemprop="title">Documentation Home</span></a></li></ul>
<ul class="nav_disambiguation"><li><a href="../index.html?s_tid=CRUX_lftnav" id="index">MATLAB</a>
</li>
<li itemscope="" itemtype="http://www.data-vocabulary.org/Breadcrumb" itemprop="breadcrumb"><a href="../mathematics.html?s_tid=CRUX_lftnav" itemprop="url"><span itemprop="title">Mathematics</span></a></li><li itemscope="" itemtype="http://www.data-vocabulary.org/Breadcrumb" itemprop="breadcrumb"><a href="../quantum-computing.html?s_tid=CRUX_lftnav" itemprop="url"><span itemprop="title">Quantum Computing</span></a></li><li itemscope="" itemtype="http://www.data-vocabulary.org/Breadcrumb" itemprop="breadcrumb"><a href="../gate-based-quantum-computing.html?s_tid=CRUX_lftnav" itemprop="url" id="mw_89c73565-106a-4694-9620-a4310ac5bfc3"><span itemprop="title">Gate-Based Quantum Computing</span></a></li></ul><div class="search_refine_v4"><div id="facets_area"><ul class="nav_scrollspy nav list-unstyled" id="pnav">
<li class="nav_scrollspy_function nav-item"><a href="#responsive_offcanvas">Ground-State Protein Folding Using Variational Quantum Eigensolver (VQE)</a></li>
<li class="nav_scrollspy_title nav-item" id="SSPY810-section">On this page</li>
<!--ADD_REFENTRY_TITLE_HERE 11--><li class="nav-item"><a href="#ProteinFoldingVQEExample-1" class="nav-link intrnllnk">Model Protein Fold with Qubits</a></li><li class="nav-item"><a href="#ProteinFoldingVQEExample-4" class="nav-link intrnllnk">Write Function to Calculate Energy of Folds</a></li><li class="nav-item"><a href="#ProteinFoldingVQEExample-5" class="nav-link intrnllnk">Compute Minimum Energy for All Folds</a></li><li class="nav-item"><a href="#ProteinFoldingVQEExample-6" class="nav-link intrnllnk">Write CVaR-VQE Objective Function</a></li><li class="nav-item"><a href="#ProteinFoldingVQEExample-7" class="nav-link intrnllnk">Create Circuit Ansatz</a></li><li class="nav-item"><a href="#ProteinFoldingVQEExample-8" class="nav-link intrnllnk">Simulate Iterations of CVaR-VQE</a></li><li class="nav-item"><a href="#ProteinFoldingVQEExample-9" class="nav-link intrnllnk">Run Final Iteration on QPU</a></li><li class="nav-item"><a href="#ProteinFoldingVQEExample-10" class="nav-link intrnllnk">References</a></li><li class="nav-item"><a href="#d126e67520" class="nav-link intrnllnk">See Also</a></li></ul></div></div>
</nav></div></nav>
<script src="../../includes/product/scripts/offcanvas_v2.js"></script></div><!--END.CLASS sidebar-offcanvas-->
<div class="offcanvas_content_container">
<div xmlns="http://www.w3.org/1999/xhtml" class="sticky_header_container"><div class="horizontal_nav"><div class="horizontal_nav_container"><div class="offcanvas_horizontal_nav"><div class="container-fluid"><div class="row"><div class="col-sm-12 d-none d-sm-block"><nav class="navbar navbar-default" role="navigation" id="subnav"><div><ul class="nav navbar-nav crux_browse"><li id="crux_nav_documentation" class="crux_resource active">Documentation</li><li id="crux_nav_example" class="crux_resource"><a href="../examples.html?category=gate-based-quantum-computing&amp;s_tid=CRUX_topnav">Examples</a></li><li id="crux_nav_function" class="crux_resource"><a href="../referencelist.html?type=function&amp;category=gate-based-quantum-computing&amp;s_tid=CRUX_topnav">Functions</a></li><li id="crux_nav_app" class="crux_resource"><a href="../referencelist.html?type=app&amp;category=gate-based-quantum-computing&amp;s_tid=CRUX_topnav">Apps</a></li></ul></div></nav></div><div class="d-sm-none"><div class="container-fluid"><div class="row"><div class="col-9"><div class="mobile_crux_nav_trigger"><div class="btn-group"><button type="button" class="btn btn-default dropdown-toggle" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Resources</button><ul class="dropdown-menu"><li id="crux_nav_mobile_documentation" class="crux_resource active">Documentation</li><li id="crux_nav_mobile_example" class="crux_resource"><a href="../examples.html?category=gate-based-quantum-computing&amp;s_tid=CRUX_topnav">Examples</a></li><li id="crux_nav_mobile_function" class="crux_resource"><a href="../referencelist.html?type=function&amp;category=gate-based-quantum-computing&amp;s_tid=CRUX_topnav">Functions</a></li><li id="crux_nav_mobile_app" class="crux_resource"><a href="../referencelist.html?type=app&amp;category=gate-based-quantum-computing&amp;s_tid=CRUX_topnav">Apps</a></li></ul></div></div></div><div class="col-3"><div class="translate_placeholder"></div></div></div></div></div></div></div></div></div></div></div><div class="content_container" id="content_container" itemprop="content">
<div class="container-fluid">
<div class="row">
<div class="col-12">

<main id="skip_link_anchor" tabindex="-1">
<div xmlns="http://www.w3.org/1999/xhtml" id="product_info_alert"></div><section xmlns="http://www.w3.org/1999/xhtml" id="doc_center_content" lang="en" data-language="en"><div id="pgtype-topic">
<section><h1 class="r2025b" itemprop="title content" id="mw_87845a3f-2f91-4f14-b71a-c6542f84c6c9"><strong class="emphasis bold">Ground-State Protein Folding Using Variational Quantum Eigensolver (VQE)</strong></h1><div class="examples_short_list hidden_ios_android" data-products="ML QUANTUM GD"><div data-pane="metadata" class="card metadata_container"><div class="card-body metadata_content"><p class="add_margin_5">This example uses:</p><ul class="list-unstyled add_border_bottom example_product_list" itemprop="requiredprods"><li><a href="matlab:matlab.internal.addons.showAddon('QUANTUM')">MATLAB Support Package for Quantum Computing</a></li><li><a href="matlab:matlab.internal.addons.showAddon('GD')">Global Optimization Toolbox</a></li></ul><div class="d-grid"><a class="btn btn_color_blue" href="matlab:openExample('quantum/ProteinFoldingVQEExample')" data-ex-genre="Live Script">Open Live Script</a></div></div></div></div><div itemscope="" itemtype="http://www.mathworks.com/help/schema/MathWorksDocPage/Example" itemprop="example" class="em_example"><meta itemprop="exampleid" content="quantum-ProteinFoldingVQEExample"><meta itemprop="exampletitle" content="GroundState Protein Folding Using Variational Quantum Eigensolver (VQE)"></div><span id="ProteinFoldingVQEExample" class="anchor_target"></span><p class="shortdesc">This example shows an efficient method for using qubits to encode a protein fold on a 3-D tetrahedral lattice <a href="ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html#mw_rtc_ProteinFoldingVQEExample_M_D161DD34" class="intrnllnk">[1]</a>, <a href="ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html#mw_rtc_ProteinFoldingVQEExample_M_B2818322" class="intrnllnk">[2]</a>. The ground-state is found through a simulated variational quantum eigensolver (VQE) routine. The VQE algorithm uses classical optimization to improve the initial guess of the ground state, and then a quantum computer calculates the expectation value. The final circuit from the simulation is run on a real QPU for comparison.</p><p>The protein is a neuropeptide with seven amino acids, APRLRFY, pictured below. The example assumes a coarse-grained protein model, where "beads" representing amino acids can traverse the lattice and interact with each other. Each bond between amino acids can be in one of four directions, corresponding to corners of a tetrahedron. These four turns can be represented by two qubits.</p><div class="informalfigure"><div id="d126e67256" class="mediaobject"><p><img src="../../examples/quantum/win64/ProteinFoldingVQEExample_01.png" alt="neuropeptide-APRLRFY-image.png" height="217" width="704"></p></div></div><div class="procedure"><h3 class="title" id="ProteinFoldingVQEExample-1"><strong class="emphasis bold">Model Protein Fold with Qubits</strong></h3><p>The purpose of the embedding methods of <a href="ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html#mw_rtc_ProteinFoldingVQEExample_M_D161DD34" class="intrnllnk">[1]</a> and <a href="ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html#mw_rtc_ProteinFoldingVQEExample_M_B2818322" class="intrnllnk">[2]</a> is to model the physical pairwise interaction energy of the protein beads while also imposing energy penalties on unrealistic configurations (such as overlaps or beads on the same lattice site). Therefore, the example is configurable in that you can modify the amino acid letters to test the effects on folding. However, the example code assumes a protein with seven amino acids, so you cannot change the length of the protein string.</p><h4 class="title" id="ProteinFoldingVQEExample-2"><strong class="emphasis bold">Configuration Qubits</strong></h4><p>A protein of <code class="literal">N</code> beads (here <code class="literal">N=7</code>) can make <code class="literal">N-1</code> turns, therefore <code class="literal">2*(N-1)=12</code> bits are required for the APRLRFY protein bonds. However, without loss of generality, the first two turns can be fixed to <code class="literal">01</code> and <code class="literal">00</code>. One of the bits in the third turn is fixed due to other symmetry considerations. The <code class="literal">turn2qubit</code> mapping depicts the 12 bits, denoting the value of the 5 that are fixed, and the 7 that are variable which will be represented by qubits. For details, see the dense encoding scheme in <a href="ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html#mw_rtc_ProteinFoldingVQEExample_M_B2818322" class="intrnllnk">[2]</a>.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>hyperParams.protein = <span style="color:#A020F0">'APRLRFY'</span>;                     
hyperParams.turn2qubit = <span style="color:#A020F0">'0100q1qqqqqq'</span>;            
hyperParams.numQubitsConfig = sum(hyperParams.turn2qubit==<span style="color:#A020F0">'q'</span>);</pre></div></div></div><h4 class="title" id="ProteinFoldingVQEExample-3"><strong class="emphasis bold">Interaction Qubits</strong></h4><p>The methods of <a href="ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html#mw_rtc_ProteinFoldingVQEExample_M_D161DD34" class="intrnllnk">[1]</a> and <a href="ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html#mw_rtc_ProteinFoldingVQEExample_M_B2818322" class="intrnllnk">[2]</a> can consider interactions between an arbitrary number of nearest-neighbors (NN). This example only considers 1-NN interaction terms, which are only possible between some beads due to the structure of the lattice. Beads separated by less than 5 bonds cannot be 1-NN (Eq. 29 of <a href="ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html#mw_rtc_ProteinFoldingVQEExample_M_B2818322" class="intrnllnk">[2]</a>). There are two interaction pairs in the length-7 protein, between beads 1 and 6, and between beads 2 and 7. Two interaction bits are used to specify whether there is any interaction between the beads in each of these pairs.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>hyperParams.numQubitsInteraction = 2;</pre></div></div></div><p>A matrix of contact energy values is used as a look-up table for pairwise interaction between different amino acids. For this example, the values are chosen at random.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre><span style="color:#0000FF">function</span> mat = buildMJInteractions(protein)
<span style="color:#228B22">% Create the MJ interaction energy matrix for the protein, specified with</span>
<span style="color:#228B22">% 1-letter codes </span>
N = length(protein);
mat = zeros(N,N);
rng(29507)
MJ = rand(20)*-6;
MJ = triu(MJ) + triu(MJ, 1)';
acids = [<span style="color:#A020F0">"C"</span>,<span style="color:#A020F0">"M"</span>,<span style="color:#A020F0">"F"</span>,<span style="color:#A020F0">"I"</span>,<span style="color:#A020F0">"L"</span>,<span style="color:#A020F0">"V"</span>,<span style="color:#A020F0">"W"</span>,<span style="color:#A020F0">"Y"</span>,<span style="color:#A020F0">"A"</span>,<span style="color:#A020F0">"G"</span>,<span style="color:#A020F0">"T"</span>,<span style="color:#A020F0">"S"</span>,<span style="color:#A020F0">"N"</span>,<span style="color:#A020F0">"Q"</span>,<span style="color:#A020F0">"D"</span>,<span style="color:#A020F0">"E"</span>,<span style="color:#A020F0">"H"</span>,<span style="color:#A020F0">"R"</span>,<span style="color:#A020F0">"K"</span>,<span style="color:#A020F0">"P"</span>];
acid2idx = dictionary(acids, 1:20);
<span style="color:#0000FF">for</span> i = 1:N
    <span style="color:#0000FF">for</span> j=1:N
        mat(i,j) = MJ(acid2idx(protein(i)), acid2idx(protein(j)));
    <span style="color:#0000FF">end</span>
<span style="color:#0000FF">end</span>
<span style="color:#0000FF">end</span></pre></div></div></div><p>Call the <code class="literal">buildMJInteractions</code> function to find the interaction energies for the protein.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>hyperParams.interactionEnergy = buildMJInteractions(hyperParams.protein);</pre></div></div></div><h3 class="title" id="ProteinFoldingVQEExample-4"><strong class="emphasis bold">Write Function to Calculate Energy of Folds</strong></h3><p>The <code class="literal">exactHamiltonian</code> function calculates the energy for each possible fold of the protein. Only 1-NN interactions are considered, and energy penalties are imposed for unrealistic configurations.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre><span style="color:#0000FF">function</span> energies = exactHamiltonian(bitstrings,hyperParams)
<span style="color:#228B22">% Compute the Hamiltonian for each bit string (i.e., the energy for each fold).</span>
<span style="color:#228B22">% See [2] for details. This does not consider the Hch constraint from</span>
<span style="color:#228B22">% side-chains and the interaction term is only 1-nearest-neighbor (1-NN).</span>

<span style="color:#228B22">% H = Hgc + Hin_1</span>

lambdaDis = 720;    <span style="color:#228B22">% Penalty for interaction distance</span>
lambdaLoc = 20;     <span style="color:#228B22">% Penalty for interaction location</span>
lambdaBack = 50;    <span style="color:#228B22">% Penalty for unphysical geometry</span>

energies = zeros(size(bitstrings,1),1);
numBeads = length(hyperParams.protein);

<span style="color:#0000FF">for</span> idx = 1:length(energies)
    bitstring = bitstrings(idx,:);
    config = hyperParams.turn2qubit; 
    config(config==<span style="color:#A020F0">'q'</span>) = bitstring(1:hyperParams.numQubitsConfig);
    turns = bin2dec(reshape(config,2,numBeads-1)');
    
<span style="color:#228B22">    %% Geometric Hamiltonian Hgc</span>

    <span style="color:#228B22">% Count number of adjacent turns which are equal and impose a penalty for each</span>
    energies(idx) = lambdaBack*sum(turns(1:end-1) == turns(2:end));
  
<span style="color:#228B22">    %% 1-NN Interaction Hamiltonian Hin</span>
    currInteractionQubit = hyperParams.numQubitsConfig;
    <span style="color:#0000FF">for</span> i=1:(numBeads-4) 
       <span style="color:#0000FF">for</span> j=(i+5):2:numBeads 
           
           currInteractionQubit = currInteractionQubit+1;
           <span style="color:#0000FF">if</span> bitstring(currInteractionQubit)==<span style="color:#A020F0">'0'</span>
               <span style="color:#0000FF">continue</span>;
           <span style="color:#0000FF">end</span>       
            
           <span style="color:#228B22">% Add the interaction energy </span>
           energies(idx) = energies(idx) + hyperParams.interactionEnergy(i,j);
            
           <span style="color:#228B22">% Compute distances between interacting beads</span>
           deltaN_ij = zeros(1,4);
           deltaN_ir = zeros(1,4);
           deltaN_mj = zeros(1,4);
           <span style="color:#0000FF">for</span> k=0:3
               deltaN_ij(k+1) = (-1).^(i:j-1)*(turns(i:j-1) == k);
               deltaN_ir(k+1) = (-1).^(i:j-2)*(turns(i:j-2) == k);
               deltaN_mj(k+1) = (-1).^(i+1:j-1)*(turns(i+1:j-1) == k);
           <span style="color:#0000FF">end</span>
           d_ij = norm(deltaN_ij)^2;
           d_ir = norm(deltaN_ir)^2;
           d_mj = norm(deltaN_mj)^2;
            
           <span style="color:#228B22">% Add penalty for distance not equal to 1</span>
           energies(idx) = energies(idx) + lambdaDis*(d_ij-1);         
            
           <span style="color:#228B22">% Add penalty for unphysical nearest neighbour collisons</span>
           energies(idx) = energies(idx) + lambdaLoc*(2-d_ir);
           energies(idx) = energies(idx) + lambdaLoc*(2-d_mj);
           <span style="color:#0000FF">if</span> i-1 &gt;= 1
               <span style="color:#0000FF">for</span> k=0:3
                   deltaN_mj(k+1) = (-1).^(i-1:j-1)*(turns(i-1:j-1) == k);
               <span style="color:#0000FF">end</span>
               d_mj = norm(deltaN_mj)^2;
               energies(idx) = energies(idx) + lambdaLoc*(2-d_mj);
           <span style="color:#0000FF">end</span>
           
           <span style="color:#0000FF">if</span> j+1 &lt;= numBeads
               <span style="color:#0000FF">for</span> k=0:3
                   deltaN_ir(k+1) = (-1).^(i:j)*(turns(i:j) == k);
               <span style="color:#0000FF">end</span>
               d_ir = norm(deltaN_ir)^2;
               energies(idx) = energies(idx) + lambdaLoc*(2-d_ir);
           <span style="color:#0000FF">end</span>
       <span style="color:#0000FF">end</span>
    <span style="color:#0000FF">end</span>
<span style="color:#0000FF">end</span>
<span style="color:#0000FF">end</span></pre></div></div></div><h3 class="title" id="ProteinFoldingVQEExample-5"><strong class="emphasis bold">Compute Minimum Energy for All Folds</strong></h3><p>Nine qubits are required to fully model a fold (7 configuration qubits and 2 interaction qubits). Use the <code class="literal">exactHamiltonian</code> function directly with all possible bit strings (each representing a possible fold), to find the minimum energy fold. You can later compare this value to the result of the quantum-based optimization. This exhaustive search is realistic for small proteins, but is not practical for larger proteins since the number of combinations of folds grows quickly.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>hyperParams.numQubitsTotal = hyperParams.numQubitsConfig + hyperParams.numQubitsInteraction; 

allFolds = dec2bin(0:2^hyperParams.numQubitsTotal-1,hyperParams.numQubitsTotal);
allEnergies = exactHamiltonian(allFolds,hyperParams);

hyperParams.GroundState.Energy = min(allEnergies);
hyperParams.GroundState.Index = find(allEnergies == hyperParams.GroundState.Energy);
allFolds(hyperParams.GroundState.Index,:)</pre></div></div></div><div class="code_responsive"><div class="programlisting"><div class="codeoutput"><pre>ans = <span class="emphasis"><em>2×9 char array</em></span>
    '101000110'
    '101001010'

</pre></div></div></div><p>There are two lowest-energy folds because the last amino acid can occupy either position in the lattice. Find the energy of each of the identified folds.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>allEnergies(hyperParams.GroundState.Index)</pre></div></div></div><div class="code_responsive"><div class="programlisting"><div class="codeoutput"><pre>ans = <span class="emphasis"><em>2×1</em></span>

   -4.7973
   -4.7973

</pre></div></div></div><p>This minimum-energy value matches the interaction energy between beads 1 and 6.</p><h3 class="title" id="ProteinFoldingVQEExample-6"><strong class="emphasis bold">Write CVaR-VQE Objective Function</strong></h3><p>Next, use a quantum circuit to translate this optimization problem over a set of bit strings into a different optimization problem, this one over a set of angles between <code class="literal remove_text_wrapping">-pi</code> and <code class="literal">pi</code>. These angles have no connection to the angles between the protein beads. The objective function accepts the set of angles for use inside of the quantum circuit, and the circuit returns various bit strings with different probabilities. Call the <code class="literal">exactHamiltonian</code> function on the bit strings returned by the quantum circuit, and use a weighted mean of the smaller energies computed as the value of the objective function.</p><p>Specifically, after the energy is computed for each observed fold, the associated probabilities are sorted by energy. The objective function returns an expectation energy computed from the tail end of the probability distribution, cutoff by an alpha parameter. This expectation energy is a conditional value at risk (CVaR). An alpha value of 0.05 was used experimentally in <a href="ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html#mw_rtc_ProteinFoldingVQEExample_M_D161DD34" class="intrnllnk">[1]</a>, but for a noise-free simulation <code class="literal">ProteinVQEObjective</code> uses a smaller cutoff value of 0.025.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre><span style="color:#0000FF">function</span> [energy, maxProbFold] = ProteinVQEObjective(parameters,hyperParams)    
<span style="color:#228B22">% Construct and simulate the variational circuit </span>
ansatz = ProteinConfigAnsatz(parameters);
qState = simulate(ansatz);
allProbs = (qState.Amplitudes).^2;

<span style="color:#228B22">% There are 10 qubits in the circuit, but only these 9 are used to define a fold </span>
foldQubits = [1:8 10];

<span style="color:#228B22">% Get the most probable fold</span>
<span style="color:#228B22">% Only compute this if second output maxProbFold is requested</span>
<span style="color:#0000FF">if</span> nargout &gt; 1 
    [~,idx] = max(allProbs);
    maxProbKet = char(qState.BasisStates(idx));
    maxProbFold = maxProbKet(foldQubits);
<span style="color:#0000FF">end</span>

<span style="color:#228B22">% Sample, and query/get the states and probabilities of the fold qubits </span>
qMeasurement = randsample(qState, hyperParams.numShots);
[states, probs] = querystates(qMeasurement, foldQubits);

<span style="color:#228B22">% Sort the probabilities by the energy</span>
[energies,sort_idx] = sort(exactHamiltonian(char(states), hyperParams));
probs = probs(sort_idx);

<span style="color:#228B22">% Compute CVaR over the low energy tail of the energy distribution,</span>
<span style="color:#228B22">% delimited by a cutoff parameter alpha. </span>
alpha = .025;  
cut_idx = nnz(cumsum(probs) &lt; alpha);
cvar_probs = probs(1:cut_idx);
cvar_probs(end+1) = alpha - sum(cvar_probs);

<span style="color:#228B22">% Compute expectation energy as the sum of cutoff state energies weighted by their probability </span>
energy = dot(cvar_probs, energies(1:cut_idx+1))/alpha;
<span style="color:#0000FF">end</span></pre></div></div></div><p>Define the number of shots to use in <code class="literal">ProteinVQEObjective</code>, and create a function handle that passes in all of the parameter values to <code class="literal">ProteinVQEObjective</code>.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>hyperParams.numShots = 1024; 
objFcn = @(theta) ProteinVQEObjective(theta,hyperParams);</pre></div></div></div><h3 class="title" id="ProteinFoldingVQEExample-7">Create Circuit Ansatz</h3><p>Create and plot the variational circuit ansatz for this protein with random angles. Qubits 1-7 represent the configuration, and the other three qubits are for the interaction (including a helper qubit that does not get measured). This circuit can be found as Figure 3 in <a href="ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html#mw_rtc_ProteinFoldingVQEExample_M_D161DD34" class="intrnllnk">[1]</a>.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre><span style="color:#0000FF">function</span> ansatz = ProteinConfigAnsatz(parameters)
<span style="color:#228B22">% Create the circuit ansatz for a 7 amino acid neuropeptide (10 qubit circuit).</span>
parameters = reshape(parameters, [2 9]);

gates = [hGate([1:7 9 10])
         ryGate([1:7 9 10], parameters(1,:))
         cxGate(1:4, 2:5)
         cxGate(5,10)
         cxGate(10,9)
         cxGate(9,8)
         cxGate(8,9)
         cxGate(9,8)
         cxGate([8 7 6], [7 6 1])
         ryGate([1:8 10], parameters(2,:))
        ];

ansatz = quantumCircuit(gates);
<span style="color:#0000FF">end</span></pre></div></div></div><p>Call <code class="literal">ProteinConfigAnsatz</code> with random angles to construct the circuit. Plot the circuit to view the qubits and gates.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>ansatz = ProteinConfigAnsatz(rand(2,9));
plot(ansatz)</pre></div></div></div><div class="informalfigure"><div id="d126e67402" class="mediaobject"><p><img src="../../examples/quantum/win64/ProteinFoldingVQEExample_02.png" alt="Figure contains an object of type quantum.gate.quantumcircuitchart." width="560"></p></div></div><h3 class="title" id="ProteinFoldingVQEExample-8"><strong class="emphasis bold">Simulate Iterations of CVaR-VQE</strong></h3><p>There are two layers of RY rotation gates over the configuration and interaction qubits. These rotation angles are learned parameters in the variational circuit. Use <code class="literal">surrogateopt</code> (Global Optimization Toolbox) with the objective function to find the set of RY rotation angles that produce the minimum expectation energy. The original paper <a href="ground-state-protein-folding-using-variational-quantum-eigensolver-vqe.html#mw_rtc_ProteinFoldingVQEExample_M_D161DD34" class="intrnllnk">[1]</a> uses a genetic algorithm to find the rotation angles. <code class="literal">surrogateopt</code> converges to similar values, but because it uses intervals internally, the convergence behavior is comparatively different.</p><p>Define the number of angles and set options for the maximum number of function evaluations, plotting function, and initial points. Then call <code class="literal">surrogateopt</code> with the objective function, upper and lower bounds for the angles, and options.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>numAngles = 2*hyperParams.numQubitsTotal; 
rng <span style="color:#A020F0">default</span>

options = optimoptions(<span style="color:#A020F0">"surrogateopt"</span>,<span style="color:#0000FF">...</span>
    <span style="color:#A020F0">"MaxFunctionEvaluations"</span>,10, <span style="color:#0000FF">...</span>
    <span style="color:#A020F0">"PlotFcn"</span>,<span style="color:#A020F0">"optimplotfval"</span>,<span style="color:#0000FF">...</span>
    <span style="color:#A020F0">"InitialPoints"</span>,pi*ones(numAngles,1));

lb = repmat(-pi,numAngles,1);
ub = repmat(pi,numAngles,1);
[angles,minEnergy] = surrogateopt(objFcn,lb,ub,[],[],[],[],[],options);</pre></div></div></div><div class="informalfigure"><div id="d126e67426" class="mediaobject"><p><img src="../../examples/quantum/win64/ProteinFoldingVQEExample_03.png" alt="Figure Optimization Plot Function contains an axes object. The axes object with title Current Function Value: -4.79728, xlabel Iteration, ylabel Function value contains an object of type scatter." width="560"></p></div></div><div class="code_responsive"><div class="programlisting"><div class="codeoutput"><pre>surrogateopt stopped because it exceeded the function evaluation limit set by 
'options.MaxFunctionEvaluations'.
</pre></div></div></div><p>Call the objective function using the optimized angles to find the state bit string with highest probability as well as its associated energy.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>[groundStateEnergy,groundStateFold] = ProteinVQEObjective(angles,hyperParams)</pre></div></div></div><div class="code_responsive"><div class="programlisting"><div class="codeoutput"><pre>groundStateEnergy = -4.7973
</pre></div></div></div><div class="code_responsive"><div class="programlisting"><div class="codeoutput"><pre>groundStateFold = 
'101000110'
</pre></div></div></div><p>This ground-state fold is one of the two folds obtained earlier with the minimum energy calculation.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>allFolds(allEnergies==minEnergy,:)</pre></div></div></div><div class="code_responsive"><div class="programlisting"><div class="codeoutput"><pre>ans = <span class="emphasis"><em>2×9 char array</em></span>
    '101000110'
    '101001010'

</pre></div></div></div><p>Visualize the ground-state fold using the <code class="literal">plotProtein</code> function, which enables you to plot the protein structure from the qubit values.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre><span style="color:#0000FF">function</span> plotProtein(bitstring,hyperParams)
<span style="color:#228B22">% Plot protein structure from the bitstring</span>

<span style="color:#228B22">% The input bitstring is expected to be of length 9, with the first 7 bits</span>
<span style="color:#228B22">% specifying turns in direction in the structure, and the last 2 bits</span>
<span style="color:#228B22">% specifying interactions between beads.</span>

<span style="color:#228B22">% Number of beads</span>
N = length(hyperParams.protein);

<span style="color:#228B22">% Construct 3D coordinates representing the 4 corners of a tetrahedron</span>
<span style="color:#228B22">% centered in 0. These represent the 4 directions each new bead might</span>
<span style="color:#228B22">% be added on in a tetrahedral grid.</span>
turn2bead = ones(4,3);
turn2bead(2:4,:) = -1+2*eye(3);

<span style="color:#228B22">% Construct complete bitstring by inserting input bitstring into</span>
<span style="color:#228B22">% the complete string mask.</span>
completeBitstring = hyperParams.turn2qubit;
completeBitstring(completeBitstring==<span style="color:#A020F0">'q'</span>) = bitstring(1:hyperParams.numQubitsConfig);

 <span style="color:#228B22">% Each pair of bits is converted into a number between 0 and 3</span>
turns = bin2dec(reshape(completeBitstring,2,[])');

<span style="color:#228B22">% Change direction in which we follow the tetrahedral grid in each bead</span>
<span style="color:#228B22">% on the line.</span>
signs = (-1).^(0:N-1)';

<span style="color:#228B22">% Compute placements of each bead.</span>
beads = cumsum(signs.*[zeros(1,3);turn2bead(turns+1,:)]);

<span style="color:#228B22">% Plot the beads connecting by lines, and add a text label to each</span>
figure
plot3(beads(:,1),beads(:,2),beads(:,3),<span style="color:#A020F0">'.-'</span>,<span style="color:#A020F0">'LineWidth'</span>,2,<span style="color:#A020F0">'MarkerSize'</span>,80,<span style="color:#A020F0">'SeriesIndex'</span>,1)
axis <span style="color:#A020F0">off</span>

viewDir = -[6 4 1];
view(viewDir);

<span style="color:#228B22">% Plot text, ensuring it is in front of the lines</span>
beadsText = beads + 0.03*viewDir;
text(beadsText(:,1),beadsText(:,2),beadsText(:,3),hyperParams.protein', <span style="color:#0000FF">...</span>
    <span style="color:#A020F0">'FontWeight'</span>, <span style="color:#A020F0">'bold'</span>, <span style="color:#A020F0">'HorizontalAlignment'</span>,<span style="color:#A020F0">'center'</span>)

<span style="color:#228B22">% Whether there are interactions between any pair of beads is determined</span>
<span style="color:#228B22">% by the additional bits in the string.</span>
interactions = [];
currInteractionQubit = hyperParams.numQubitsConfig+1;

<span style="color:#0000FF">for</span> i=1:(N-5)
    <span style="color:#0000FF">for</span> j=(i+5):2:N
        <span style="color:#0000FF">if</span> bitstring(currInteractionQubit) == <span style="color:#A020F0">'1'</span>
            interactions = [interactions;beads(i,:);beads(j,:);nan*ones(1,3)]; <span style="color:#228B22">%#ok&lt;AGROW&gt;</span>
        <span style="color:#0000FF">end</span>
        currInteractionQubit = currInteractionQubit+1;
    <span style="color:#0000FF">end</span>
<span style="color:#0000FF">end</span>

<span style="color:#0000FF">if</span> ~isempty(interactions)
    hold <span style="color:#A020F0">on</span>
    plot3(interactions(:,1),interactions(:,2),interactions(:,3),<span style="color:#A020F0">'k--'</span>,<span style="color:#A020F0">'LineWidth'</span>,2)
    hold <span style="color:#A020F0">off</span>
    legend([hyperParams.protein+<span style="color:#A020F0">" Protein Structure"</span>;<span style="color:#A020F0">"Interactions"</span>], <span style="color:#A020F0">"Location"</span>,<span style="color:#A020F0">"southoutside"</span>)
<span style="color:#0000FF">else</span>
    legend(hyperParams.protein+<span style="color:#A020F0">" Protein Structure"</span>, <span style="color:#A020F0">"Location"</span>,<span style="color:#A020F0">"southoutside"</span>)
<span style="color:#0000FF">end</span>
<span style="color:#0000FF">end</span></pre></div></div></div><p>The protein has two possible interactions considered in the 1-NN model. The fold with the lowest energy only has one of these interactions. Use <code class="literal">plotProtein</code> to visualize the lowest energy fold.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>plotProtein(groundStateFold,hyperParams)</pre></div></div></div><div class="informalfigure"><div id="d126e67460" class="mediaobject"><p><img src="../../examples/quantum/win64/ProteinFoldingVQEExample_04.png" width="560"></p></div></div><p>Next, construct the quantum circuit using the optimized angles and simulate the circuit to see the expected probability distribution over states. Use a threshold to filter out states with probabilities less than 2%. The ground-state fold <code class="literal">101000110</code> appears again as the state with the highest probability.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>optimized_circuit = ProteinConfigAnsatz(angles);
sv = simulate(optimized_circuit);
histogram(sv,[1:8 10],Threshold=0.02)</pre></div></div></div><div class="informalfigure"><div id="d126e67470" class="mediaobject"><p><img src="../../examples/quantum/win64/ProteinFoldingVQEExample_05.png" alt="Figure contains an axes object. The axes object with ylabel Probability contains an object of type categoricalhistogram." width="560"></p></div></div><h3 class="title" id="ProteinFoldingVQEExample-9"><strong class="emphasis bold">Run Final Iteration on QPU</strong></h3><p>Connect to the IonQ device using <code class="literal">quantum.backend.QuantumDeviceAWS</code>. Specify the region of the device and path to a bucket to store results.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>reg = <span style="color:#A020F0">"us-east-1"</span>;
bucketPath = <span style="color:#A020F0">"s3://amazon-braket-mathworks/doc-examples"</span>;
device = quantum.backend.QuantumDeviceAWS(<span style="color:#A020F0">"Harmony"</span>,S3Path=bucketPath,Region=reg)</pre></div></div></div><div class="code_responsive"><div class="programlisting"><div class="codeoutput"><pre>device = 
  QuantumDeviceAWS with properties:

         Name: "Harmony"
    DeviceARN: "arn:aws:braket:us-east-1::device/qpu/ionq/Harmony"
       Region: "us-east-1"
       S3Path: "s3://amazon-braket-mathworks/doc-examples"

</pre></div></div></div><p>Create a task to run the circuit ansatz with optimized angles on the QPU. Specify the number of shots as 500.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>task = run(optimized_circuit,device,NumShots=500);
wait(task)</pre></div></div></div><p>Fetch the results and plot a histogram of the states for all but the ninth qubit. Specify a lower threshold of 2% to filter out unlikely states.</p><div class="code_responsive"><div class="programlisting"><div class="codeinput"><pre>results = fetchOutput(task);
histogram(results,[1:8 10],Threshold=0.02)</pre></div></div></div><div class="informalfigure"><div id="d126e67493" class="mediaobject"><p><img src="../../examples/quantum/win64/ProteinFoldingVQEExample_06.png" alt="Figure Optimization Plot Function contains an axes object. The axes object with title Current Function Value: -4.79728, xlabel Iteration, ylabel Probability contains an object of type categoricalhistogram." width="560"></p></div></div><p>The ground-state fold <code class="literal">101000110</code> appears again as the state with the highest probability, so the QPU results agree with the local simulation of the circuit.</p><h3 class="title" id="ProteinFoldingVQEExample-10">References</h3><span id="mw_rtc_ProteinFoldingVQEExample_M_D161DD34" class="anchor_target"></span><p>[1] Robert, Anton, Panagiotis Kl. Barkoutsos, Stefan Woerner, and Ivano Tavernelli. “Resource-Efficient Quantum Algorithm for Protein Folding.” <span class="emphasis"><em>Npj Quantum Information</em></span> 7, no. 1 (February 17, 2021): 38. <a href="https://doi.org/10.1038/s41534-021-00368-4" target="_blank">https://doi.org/10.1038/s41534-021-00368-4.</a></p><span id="mw_rtc_ProteinFoldingVQEExample_M_B2818322" class="anchor_target"></span><p>[2] Robert, Anton, Panagiotis Kl. Barkoutsos, Stefan Woerner, and Ivano Tavernelli. “Supplementary Information for 'Resource-Efficient Quantum Algorithm for Protein Folding'" <span class="emphasis"><em>Npj Quantum Information</em></span> 7, no. 1 (February 17, 2021): 38. <a href="https://doi.org/10.1038/s41534-021-00368-4" target="_blank">https://doi.org/10.1038/s41534-021-00368-4.</a></p></div>
      <h2 id="d126e67520">See Also</h2><p><span itemscope="" itemtype="http://www.mathworks.com/help/schema/MathWorksDocPage/SeeAlso" itemprop="seealso"><a itemprop="url" href="../ref/quantumcircuit.html"><span itemprop="name"><code class="class">quantumCircuit</code></span></a></span></p>
      <h3 id="d126e67526">Topics</h3><ul class="list-unstyled"><li><a href="introduction-to-quantum-computing.html" class="a">Introduction to Quantum Computing</a></li><li><a href="run-quantum-circuit-on-hardware-using-AWS.html" class="a">Run Quantum Circuit on Hardware Using AWS</a></li><li><a href="graph-coloring-with-grovers-algorithm.html" class="a">Graph Coloring with Grover's Algorithm</a></li><li><a href="solve-xor-problem-using-quantum-neural-network.html" class="a">Solve XOR Problem Using Quantum Neural Network (QNN)</a></li><li><a href="quantum-monte-carlo-simulation.html" class="a">Quantum Monte Carlo (QMC) Simulation</a></li></ul>
      <h3 id="d126e67539">External Websites</h3><ul class="list-unstyled"><li><a href="https://www.mathworks.com/videos/vqe-with-matlab-1720589081601.html" class="video">VQE with <span class="trademark entity">MATLAB</span></a></li></ul>
    </section>
    </div></section><div xmlns="http://www.w3.org/1999/xhtml" class="clearfix"></div>
<div xmlns="http://www.w3.org/1999/xhtml" align="center" class="feedbackblock" id="mw_docsurvey"><script src="https://www.mathworks.com/help/docsurvey/docfeedback.js"></script>
<script>loadSurveyHidden();</script>
<link rel="stylesheet" href="https://www.mathworks.com/help/docsurvey/release/index-css.css" type="text/css">
<script src="https://www.mathworks.com/help/docsurvey/release/bundle.index.js"></script>

<script>initDocSurvey();</script></div></main>


</div>
</div>
</div>
</div><!--close_0960-->
<footer xmlns="http://www.w3.org/1999/xhtml" id="footer" class="bs-footer">
<div class="container-fluid">
<div class="footer">
<div class="row">
<div class="col-12">
<p class="copyright">© 1994-2025 The MathWorks, Inc.</p>
<ul class="footernav"><li class="footernav_help"><a href="matlab:web(matlab.internal.licenseAgreement)">Terms of Use</a></li><li class="footernav_patents"><a href="matlab:web([matlabroot '/patents.txt'])">Patents</a></li><li class="footernav_trademarks"><a href="matlab:web([matlabroot '/trademarks.txt'])">Trademarks</a></li><li class="footernav_piracy"><a href="matlab:web([docroot '/acknowledgments.html'])">Acknowledgments</a></li></ul></div>
</div>
</div>
</div>
</footer>
</div><!--close row-offcanvas-->
</div><!--close_0970-->
</body>
</html>
